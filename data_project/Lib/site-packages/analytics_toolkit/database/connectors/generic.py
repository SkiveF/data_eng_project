""" All generic methods for data warehouse (Snowflake, Yellowbrick ...) connection. """
import abc
import os
import warnings
from contextlib import contextmanager
from getpass import getpass, getuser
from typing import Any, Optional, Union
from uuid import uuid4

import pandas as pd
from analytics_toolkit.sql import is_table_name
from sqlalchemy import VARCHAR, inspect
from sqlalchemy.engine.base import Connection, Engine
from sqlalchemy.engine.reflection import Inspector
from sqlalchemy.sql.visitors import TraversibleType
from sqlalchemy.types import TypeEngine

SQLAlchemyType = Union[TraversibleType, TypeEngine]


class DatabaseConnector(metaclass=abc.ABCMeta):
    """All generic methods for data warehouse (Snowflake, Yellowbrick ...) connection."""

    def __init__(
        self,
        app_name: str,
        username: str = None,
        password: str = None,
    ):
        """
        Creates the database connector needed. It is based on a SQLAlchemy engine.

        Args:
            app_name (str): name of the system on which the database is hosted
            username (str, optional): username in the system. If None, tries to use the environment
                variable "{app_name}_USERNAME" (ex: YELLOWBRICK_USERNAME) or prompts the user.
            password (str, optional): password in the system. If None, tries to use the environment
                variable "{app_name}_PASSWORD" (ex: YELLOWBRICK_PASSWORD) or prompts the user.
        """
        # Generic parameters
        self.app_name = app_name

        # Credentials
        self.username = None
        self.password = None
        self.set_credentials(username=username, password=password)

        # SQLAlchemy engine to be filled in child class __init__
        self.engine = None  # type: Engine
        self.to_sql_method = "multi"

    def set_credentials(self, username: Optional[str], password: Optional[str]):
        """
        Sets credentials the following way:
            1) uses the input arguments (during class instantiation)
            2) checks in environment variables (first connector-specific, then Catalina)
            3) Prompts the user for input

        Args:
            username (Optional[str]): username in the system to access.
            password (Optional[str]): password in the system to access.
        """
        credentials = {"username": username, "password": password}
        for name, value in credentials.items():
            connector_var_name = f"{self.app_name}_{name}".upper()
            catalina_var_name = f"catalina_{name}".upper()

            # If user input an argument when instantiating a connector, uses it
            if value is not None:
                setattr(self, name, value)
            # If connector specfic credential exists in environment variables, uses it
            elif (connector_var := os.getenv(connector_var_name)) is not None:
                setattr(self, name, connector_var)
            # If Catalina credential exists in environment variables, uses it
            elif (catalina_var := os.getenv(catalina_var_name)) is not None:
                setattr(self, name, catalina_var)
            # Else, prompts the user for information
            else:
                setattr(self, name, getpass(prompt=f"{self.app_name.title()} {name}: "))

    @abc.abstractmethod
    def get_sqlalchemy_engine(self) -> Engine:
        """Gets the SQLAlchemy engine associated with"""

    def get_connection(self) -> Connection:
        return self.engine.connect()

    def execute_query(self, query: str):
        """Executes a SQL query. TODO: check if multiple queries can be passed"""
        with self.get_connection() as connection:
            result = connection.execute(query)

        return result

    @staticmethod
    def format_table_name(table_name: str) -> str:
        """
        Formats table name to lowercase. Raises warning if the table_name was not already lowercase.
        """
        if not table_name.islower():
            message = (
                f"Table name {table_name} is not fully lowercase. Such names are not accepted "
                "on some tables (ex: Yellowbrick). Converting to lowercase."
            )
            warnings.warn(message=message, category=UserWarning)

        return table_name.lower()

    def get_table(self, sql: str) -> pd.DataFrame:
        """
        Gets a table from the database.

        Args:
            sql (str): SQL query or SQL table name. Both would work!

        Returns:
            pd.DataFrame: DataFrame containing data from the SQL table / query
        """
        sql = f"SELECT * FROM {sql}" if is_table_name(sql) else sql
        with self.get_connection() as connection:
            df_table = pd.read_sql(sql, connection)

        return df_table

    def get_table_from_query(self, query: str) -> pd.DataFrame:
        """Gets a table from a SQL SELECT query."""
        message = "Method 'get_table_from_query' is deprecated. Please use 'get_table' directly."
        warnings.warn(message=message, category=DeprecationWarning)
        return self.get_table(sql=query)

    def create_table(
        self,
        data_or_query: Union[str, pd.DataFrame, pd.Series],
        table_name: str,
        if_exists: str = "fail",
        dtype: dict[str, Union[str, SQLAlchemyType]] = None,
        grant_to: Optional[str] = None,
    ):
        """
        Creates a table in the database.

        Args:
            data_or_query (Union[str, pd.DataFrame, pd.Series]): either input data
                (Series or DataFrame format) or a SQL SELECT query.
            table_name (str): name of the table to write on.
            if_exists (str, optional): 3 possibilities: "fail" (default), "replace", "append"
                "fail" will raise an error if the table exists
                "replace" will replace the table if it exists already
                "append" will append the data to the table.
            dtype (dict[str, Union[str, SQLAlchemyType]], optional): Only used when creating table
                from DataFrame. Custom optional mapping to change the dtypes of the table to create.
                Keys are columns names, values are SQL Data Types (format string or SQLAlchemy Data
                Type). Import SQLAlchemy types using: "from sqlalchemy import VARCHAR, BIGINT, ...".
                Dtype example: {"column_x": "VARCHAR(8)"} or {"column_x": VARCHAR(8)}
            grant_to (Optional[str], optional): entities to give access to. Defaults to None.
                Only "all" or None is supported
        """
        if isinstance(data_or_query, str):
            return self.create_table_from_query(
                data_or_query, table_name, if_exists=if_exists, grant_to=grant_to
            )
        else:
            return self.create_table_from_df(
                data_or_query,
                table_name,
                if_exists=if_exists,
                dtype=dtype,
                grant_to=grant_to,
            )

    def create_table_from_query(
        self,
        query: str,
        table_name: str,
        if_exists: str = "fail",
        grant_to: Optional[str] = None,
    ):
        """Creates a SQL table from a SQL SELECT query."""
        table_name = self.format_table_name(table_name)
        table_already_exists = self.has_table(table_name)

        # "replace" mode: handled in a specific method
        if if_exists == "replace":
            args = table_name, query, table_already_exists
            result = self._create_table_from_query_replace(*args)

        # "append" mode: if the table exists, insert the data, otherwise create the table
        elif if_exists == "append" and table_already_exists:
            result = self.insert_data_from_query(table_name, query)
        elif if_exists == "append" and not table_already_exists:
            result = self.execute_query(f"CREATE TABLE {table_name} AS ({query})")

        # "fail" mode: creation either works or doesn't, as expected
        else:
            result = self.execute_query(f"CREATE TABLE {table_name} AS ({query})")

        # Grant access all the time, apart if the data was appended.
        if not (if_exists == "append" and table_already_exists):
            self.grant_access(table_name, grant_to=grant_to)

        return result

    def _create_table_from_query_replace(
        self, table_name: str, query: str, table_already_exists: bool
    ):
        """
        Private method to work with the "replace" mode when creating tables from queries.
        Two possible cases:
        1) If the current table is in the query, we cannot drop the table beforehand: this would
            raise an error saying table does not exist. To bypass this issue, we create a
            temporary table, delete the original one and rename the temporary table to its
            original name.
        2) In other cases, we can safely drop the table
        """
        # Case 1): creating a temporary table. If we cannot drop the original table (for instance,
        # if we are not the owner), context manager will drop temp table to keep DB clean
        if table_already_exists and (table_name in query):
            with self._temp_table_name() as temp_table_name:
                sql = f"CREATE TABLE {temp_table_name} AS ({query})"
                result = self.execute_query(sql)
                self.drop_table(table_name)

                # Rename the newly created table to the original name.
                rename_query = f"ALTER TABLE {temp_table_name} RENAME TO {table_name}"
                self.execute_query(rename_query)

        # Case 2): safely dropping the table
        else:
            self.drop_table(table_name)
            result = self.execute_query(f"CREATE TABLE {table_name} AS ({query})")

        return result

    @contextmanager
    def _temp_table_name(self):
        """Gets a temporary table name. Deletes the table at the end, even if an error is raised."""
        temp_table_name = f"{getuser()}_temp_table_{str(uuid4()).replace('-', '')}"
        try:
            yield temp_table_name
        finally:
            self.drop_table(temp_table_name)

    def insert_data_from_query(self, table_name: str, query: str):
        """
        Inserts data from a specific SQL SELECT query into a table.

        This function creates a temporary table from the given query, get its columns, and compares
        them with the columns of the target table:
            - If there are no common columns, raises an error.
            - If the appended data contains some or all columns of the target table, appends them to
              the target table.
            - Extra columns (in the appended data but not in the target table) are ignored.

        Afterwards, the function appends data for the given columns, and NULLs for missing columns.

        If you fully know what you are doing, this function can be slow. You can directly run (at
        your own risk !) the code line below. However, if your column names are not aligned, this
        might lead to some big issues:

        >>> self.execute_query(f"INSERT INTO {table_name} ({query})")

        Args:
            table_name (str): name of the table to append data to
            query (str): SQL query generating a table
        """
        # Create the temporary table
        with self._temp_table_name() as temp_table_name:
            self.create_table(query, temp_table_name)

            # Get columns of temporary and target tables, and only keeps common ones.
            query_cols = self.get_columns(temp_table_name)
            target_cols = self.get_columns(table_name)
            append_cols = set(target_cols) & set(query_cols)

            if len(append_cols) == 0:  # no common columns, raise an error
                message = "No common columns between the query & the table_name!"
                raise ValueError(message)

            # Append the given columns, and preserves the column order (using target_cols)
            column_list = ", ".join(
                (col if col in append_cols else f"NULL AS {col}") for col in target_cols
            )
            append_query = f"SELECT {column_list} FROM {temp_table_name}"
            result = self.execute_query(f"INSERT INTO {table_name} ({append_query})")

        return result

    def create_table_from_df(
        self,
        df: Union[pd.DataFrame, pd.Series],
        table_name: str,
        if_exists: str = "fail",
        dtype: dict[str, Union[str, SQLAlchemyType]] = None,
        grant_to: Optional[str] = None,
    ):
        """Creates a SQL table from data (format Series or DataFrame)"""
        table_name = self.format_table_name(table_name)
        table_already_exists = self.has_table(table_name)
        df = self.format_data(df)

        # Change dtypes if needed: object -> VARCHAR instead of TEXT, or custom mapping
        custom_dtype = {} if dtype is None else dtype
        string_dtype = {
            col: VARCHAR
            for col, dtype in df.dtypes.to_dict().items()
            if dtype == "object"
        }

        df.to_sql(
            name=table_name,
            con=self.engine,
            if_exists=if_exists,
            index=False,
            dtype=string_dtype | custom_dtype,
            method=self.to_sql_method,
        )

        # Grant access all the time, apart if the data was appended.
        if not (if_exists == "append" and table_already_exists):
            self.grant_access(table_name, grant_to=grant_to)

    @staticmethod
    def format_data(data: Union[pd.DataFrame, pd.Series]) -> pd.DataFrame:
        """
        Args:
            data (Union[pd.DataFrame, pd.Series]): data to pass to the create_table method.

        Raises:
            ValueError: if the data is a Series with no name, no column name can be inferred.

        Returns:
            pd.DataFrame: formatted DataFrame if data was a Series, otherwise same DataFrame.
        """
        if isinstance(data, pd.Series) and data.name is None:
            raise ValueError(
                "You can't create a table from a Series with no name."
                "Please create a DataFrame from this Series or add a name to it"
            )
        elif isinstance(data, pd.Series):
            return pd.DataFrame(data, columns=[data.name])
        else:
            return data

    def grant_access(self, table_name: str, grant_to: Optional[str] = None):
        """
        Grants access to different user for a specific table.

        Args:
            table_name (str): name of the table to grant access to.
            grant_to (Optional[str], optional): entities to give access to. Defaults to "all".
                As of now, only "all" or None is supported
        """
        if grant_to == "all":
            self.execute_query(f"GRANT ALL ON {table_name} TO public")

    def drop_table(
        self,
        table_name: Union[str, list[str]],
        errors: Union[str, list[str]] = "ignore",
    ):
        """
        Drops tables based on their names.

        Args:
            table_name (Union[str, list[str]]): name or list of names to delete.
            errors (Union[str, list[str]], optional): what to do if the table does not exist.
                Can be one global option (str), or list of options (list[str]).
                "raise": raise the error. "ignore": drops if exists. Defaults to "ignore".
        """
        table_name = [table_name] if isinstance(table_name, str) else table_name
        if isinstance(errors, list) and len(errors) != len(table_name):
            raise ValueError("Length of table names is different of length of 'errors'")
        errors = errors if isinstance(errors, list) else [errors for _ in table_name]
        for name, error in zip(table_name, errors):
            name = self.format_table_name(name)
            query = "IF EXISTS" if error == "ignore" else ""
            self.execute_query(f"DROP TABLE {query} {name}")

    def has_table(self, table_name: str, schema: Optional[str] = None) -> bool:
        """
        Checks if a table is in a database.

        Args:
            table_name (str): name of the table
            schema (Optional[str], optional): schema to check. If None.

        Returns:
            bool: True if table exists, False otherwise.
        """
        inspector = inspect(self.engine)  # type: Inspector
        boolean = inspector.has_table(table_name, schema=schema)

        return boolean

    def get_table_names(self, schema: Optional[str] = None) -> list[str]:
        """
        Gets a list table names associated with the given schema (or default one).

        Args:
            schema (Optional[str], optional): schema to inspect. If None, uses the default schema
                for the database. Defaults to None.

        Returns:
            list[str]: list of table names in the given schema
        """
        inspector = inspect(self.engine)  # type: Inspector
        table_names = inspector.get_table_names(schema=schema)

        return table_names

    def get_columns(
        self, table_name: str, schema: Optional[str] = None
    ) -> dict[str, Any]:
        """
        Gets columns information: names and types. Uses SQLAlchemy as default; can be overridden.

        Args:
            table_name (str): name of the table to check the columns
            schema (Optional[str]): name of the schema of the table.

        Returns:
            dict[str, Any]: dictionary, key = column name, value = column data type (SQL)
        """
        inspector = inspect(self.engine)  # type: Inspector
        columns = inspector.get_columns(table_name, schema=schema)
        dtypes = {column["name"]: column["type"] for column in columns}

        return dtypes

    def drop_columns(self, table_name: str, columns: list[str], errors: str = "raise"):
        """
        Drops columns from the given table. Can be overridden

        Args:
            table_name (str): name of the table to drop columns on
            columns (list[str]): list of columns to drop
            errors (str, optional): "raise" = raise error if the table does not exist. "ignore" =
                ignore when some columns do not exist. Defaults to "raise".
        """
        # Get all existing columns
        table_columns = list(self.get_columns(table_name))

        # Raise if some columns to drop do not exist
        missing_columns = list(set(columns) - set(table_columns))
        if errors == "raise" and missing_columns:
            message = f"Cannot drop columns {missing_columns=} from {table_name=}!"
            raise ValueError(message)

        # Drop columns (method can vary according to connectors)
        self._drop_columns(table_name, columns, table_columns)

    @abc.abstractmethod
    def _drop_columns(
        self, table_name: str, columns: list[str], table_columns: list[str]
    ):
        """Private method to drop columns in a table. To be overridden."""
