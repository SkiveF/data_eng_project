""" Module containing a class to work with ybtools (ybsql, ybload, ybunload ...) """
import os
import warnings
from datetime import datetime, timedelta
from pathlib import Path
from shutil import which
from subprocess import CalledProcessError, CompletedProcess, run
from typing import Optional, Union

from analytics_toolkit.sql import is_table_name


class YellowbrickTools:
    """Set of tools that connect with ybtools executables (ybsql, ybload, ybunload ...)"""

    def __init__(
        self,
        username: str,
        password: str,
        database: str,
        host: Optional[str] = None,
    ) -> None:
        # Main parameters
        self.host = host if host is not None else "prodybc"
        self.username = username
        self.password = password
        self.database = database

        # ybtools parameters
        self.programs = ["ybsql", "ybload", "ybunload"]
        self.active_programs = self.get_active_programs()

        # Output directory
        # TODO: use a real TemporaryFolder from tempfile module? How to handle /workspace then?
        self.output_dir = Path(os.getcwd(), "ybtools")
        self.setup_output_directory()

        # Environment parameters
        ybtools_env = {
            "YBHOST": self.host,
            "YBUSER": self.username,
            "YBPASSWORD": self.password,
            "YBDATABASE": self.database,
        }
        self.env = dict(os.environ) | ybtools_env
        self.prefix = ""  # prefix will be defined after the ybunload process

    def get_active_programs(self) -> list[str]:
        """
        Gets all programs that can be found using command line. If not, raises a warning
        asking to add the executable folder path to the 'Path' environment variable.
        """
        active_programs = [
            program for program in self.programs if which(program) is not None
        ]
        inactive_programs = [
            program for program in self.programs if program not in active_programs
        ]
        if len(inactive_programs) > 0:  # If some programs are not found using "which"
            message = f"""
            Programs {', '.join(inactive_programs)} not found. Please add the path to the programs  
            folder to your "Path" / "PATH" environment variable, in order for command line to find 
            them easily.
            """
            warnings.warn(message=message.replace("\n", ""), category=UserWarning)

        return active_programs

    def setup_output_directory(self) -> None:
        """
        Sets up the ybtools output directory:
        - If it is not existing, creates it and give 777 access
        - Remove old files (older than 2 hours) on which you have deletion rights.
        Cleaning is done since in some cases (user interruptions, etc.) there might be some .csv
        that are failed to be deleted. These .csv might cause memory issues, so we remove them.
        However, we keep the .bad files since they can be informative for the user.
        """
        # We could also use umask & makedirs instead of makedirs & chmod.
        if not self.output_dir.exists():
            os.makedirs(self.output_dir)
            os.chmod(self.output_dir, 0o777)

        # Identify old files and delete them if you have the right to.
        two_hours_before = datetime.now() + timedelta(hours=-2)
        two_hours_before = two_hours_before.strftime("%Y%m%d_%H%M%S")
        remove_files = (
            file
            for file in os.listdir(self.output_dir)
            if Path(file).suffix == ".csv"
            and file.replace("YBLOAD_", "").replace("YBUNLOAD_", "") <= two_hours_before
        )
        for file in remove_files:
            if self._is_deletable(self.output_dir / file):
                os.remove(self.output_dir / file)

    @staticmethod
    def _is_deletable(filepath: Path) -> bool:
        """Checks if file is deletable. Coming from: https://stackoverflow.com/a/68269216"""
        if os.access(filepath, os.W_OK):  # if file_path has write permission
            # If directory containing file_path has write and execute permission
            if os.access(filepath.parent, os.W_OK | os.X_OK):
                try:  # if file_path can be opened for write (meaning it is not locked)
                    file = open(filepath, "w")  # will delete all the file content!
                    file.close()
                    return True  # file_path is not locked
                except OSError:  # if file_path can't be opened for write
                    pass  # file_path is locked

        return False

    def ybsql(self, query: str, **ybsql_options: Optional[str]) -> CompletedProcess:
        """
        Executes a SQL query or queries using ybsql executable.
        TODO: add result support (extracted DF, etc.)

        Args:
            query (str): SQL query or queries (separated by a ";") to execute
            ybsql_options (Optional[str]): other options to pass to ybsql. Due to --, you will need
                to pass them using ** in general. Example: **{"-o": "ybtools/output.txt"}. All
                options are detailed here: https://www.yellowbrick.com/docs/5.2/administration/ybsql_options.html

        Returns:
            CompletedProcess: process information (args, output in stdout, error in stderr ...)
        """
        arguments = {
            "-c": f"{query.rstrip(';')};",  # adds a final ";" if it doesn't exist already.
            "-a": None,  # -a, --echo-all: print all input lines to stdout as they are read.
            **ybsql_options,
        }
        result = self.execute(program="ybsql", arguments=arguments)

        return result

    def ybload(
        self,
        table_name: str,
        *filepaths: Union[str, Path],
        **ybload_options: Optional[str],
    ) -> CompletedProcess:
        """
        Loads a Yellowbrick table using the ybload executable. The table needs to be created
        beforehand in order for ybload to work. TODO: use * for filepaths and ** for options

        Args:
            table_name (str): name of the table to load data too. Table must be created beforehand.
            filepaths (str): path of files to load into YB. Some formats are .csv, .txt or .csv.gz.
            ybload_options (Optional[str]): Additional options to pass to ybload. You will probably
                need to pass them using **. Example: **{"--logfile": "ybtools/log/load.txt"}
                More options: https://www.yellowbrick.com/docs/5.2/bulk_loading/ybload_options.html

        Returns:
            Completed process containing the stdout / stderr of the process.
        """
        bad_row_filename = f"YBLOAD_{datetime.now().strftime('%Y%m%d_%H%M%S')}.bad"
        arguments = {
            **{str(filepath): None for filepath in filepaths},
            "--table": table_name,
            "--format": "CSV",
            "--parse-header-line": None,
            "--max-bad-rows": "0",
            "--bad-row-file": str(self.output_dir / bad_row_filename),
            **ybload_options,
        }
        result = self.execute(program="ybload", arguments=arguments)

        return result

    def ybunload(self, sql: str, **ybunload_options: Optional[str]) -> CompletedProcess:
        """
        Unloads a Yellowbrick table to a specific file using the ybunload executable.
        # TODO: return output files in ybunload statement? (along with CompletedProcess)

        Args:
            sql (str): table name or sql select query to unload.
            ybunload_options (Optional[str]): Additional options to pass to ybload. You will
                need to pass them using **.Example: **{"--logfile": "ybtools/log/unload.txt"}
                More options: https://www.yellowbrick.com/docs/5.2/unloading/ybunload_options.html

        Returns:
            Completed process containing the stdout / stderr of the process.
        """
        sql_argument = "--table" if is_table_name(sql) else "--select"
        self.prefix = f"YBUNLOAD_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        arguments = {
            sql_argument: sql,
            "-o": str(self.output_dir),
            "--prefix": self.prefix,
            "--truncate-existing": None,
            **ybunload_options,
        }
        result = self.execute(program="ybunload", arguments=arguments)

        return result

    def execute(
        self, program: str, arguments: dict[str, Optional[str]]
    ) -> CompletedProcess:
        """
        Executes any of the ybtools programs (ybunload, ybload, ybsql ...)

        Args:
            program (str): program to execute. Possible choices: ybload, ybunload, ybsql.
            arguments (dict[str, str]): arguments to pass to the program.
            Example of arguments dictionary: {"--log-level": "ERROR"}

        Raises:
            ValueError: when script is executed with exit code 1, with info from stdout and stderr.
            ValueError: when ybtools path does not exist or executables have not been found there.

        Returns:
            CompletedProcess: when the script is executed with exit code 0
        """
        self.check_if_program_active(program=program)
        args = [program, *self.parse_arguments(arguments=arguments)]

        try:
            result = run(args=args, env=self.env, capture_output=True, check=True)
        except CalledProcessError as error:
            # TODO: use logger to pass messages as a debug / info / error format.
            error_msg = (
                f"{program} failed.\n Output: {error.stdout}.\n Error: {error.stderr}"
            )
            raise ValueError(error_msg) from error

        return result

    def check_if_program_active(self, program: str):
        """
        Raises:
            ValueError: when the program has not been found when calling "{program} --version".
        """
        if program not in self.active_programs:
            message = f"""
            Did not find program {program}. Please add the path to the executable folder in the  
            "Path" / "PATH" environment variable.
            """
            raise ValueError(message.replace("\n", ""))

    @staticmethod
    def parse_arguments(arguments: dict[str, Optional[str]]) -> list[str]:
        """
        Parse arguments given as Dict into a list that can be read by subprocess.call().

        Args:
            arguments (dict[str, Optional[str]]): arguments to pass to an executable.
            Pass {key: value} for arguments that need values, {key: None} for those who don't.

        Returns:
            list[str]: list of arguments that can be read by subprocess.call().
        """
        return [
            element
            for key, value in arguments.items()
            for element in ([key, value] if value is not None else [key])
        ]
