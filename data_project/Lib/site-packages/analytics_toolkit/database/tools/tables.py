import abc
import os
import re
from datetime import date
from pathlib import Path

import pandas as pd
from analytics_toolkit.config import YellowbrickDatabases
from analytics_toolkit.database.connectors import (
    SnowflakeDatabaseConnector,
    YellowbrickDatabaseConnector,
)
from analytics_toolkit.sas import read_sas


class VersionedTable:
    """Table that contains multiple versions, defined in a version column."""

    def __init__(self, table_name: str, version_col: str) -> None:
        """
        Instantiates the class.

        Args:
            table_name (str): name of the table to store on Yellowbrick
            version_col (str): column containing the version in the table
        """
        self.table_name = table_name
        self.version_col = version_col
        self.database = YellowbrickDatabases.save
        self.yellowbrick = YellowbrickDatabaseConnector(database=self.database)

    def get_versions(self):
        if not self.yellowbrick.has_table(self.table_name):
            return []

        sql = f"""SELECT DISTINCT({self.version_col}) FROM {self.table_name}"""
        df_versions = self.yellowbrick.get_table(sql)

        versions = [
            version.strftime("%Y-%m-%d") if isinstance(version, date) else version
            for version in df_versions[self.version_col]
        ]

        return versions

    def get_select_query(self, version: str) -> str:
        """Gets the select query associated with the Yellowbrick table version."""
        sql = f"""
        SELECT
            *
        FROM
            {self.database}.public.{self.table_name}
        WHERE
            {self.version_col} = '{version}'
        """

        return sql

    def get_data(self, version: str) -> pd.DataFrame:
        """Gets the data associated with a specific version."""
        return self.yellowbrick.get_table(self.get_select_query(version))


class ExternalTable(metaclass=abc.ABCMeta):
    """Class (probably temporary) to handle ETL work that has to be done in studies as of now."""

    def __init__(self, table_name: str, version_col: str) -> None:
        """
        Instantiates the class.

        Args:
            table_name (str): name of the table to store on Yellowbrick
            version_col (str): column containing the version in the table
        """
        self.table_name = table_name
        self.version_col = version_col
        self.database = YellowbrickDatabases.save
        self.yellowbrick = YellowbrickDatabaseConnector(database=self.database)

    def get_yellowbrick_versions(self) -> list[str]:
        """Gets all versions (list of strings or dates) available on YB"""
        if not self.yellowbrick.has_table(self.table_name):
            return []

        sql = f"""SELECT DISTINCT({self.version_col}) FROM {self.table_name}"""
        df_versions = self.yellowbrick.get_table(sql)

        versions = [
            version.strftime("%Y-%m-%d") if isinstance(version, date) else version
            for version in df_versions[self.version_col]
        ]

        return versions

    def get_select_query(self, version: str) -> str:
        """Gets the select query associated with the Yellowbrick table version."""
        sql = f"""
        SELECT
            *
        FROM
            {self.database}.public.{self.table_name}
        WHERE
            {self.version_col} = '{version}'
        """

        return sql

    def get_table(self, version: str) -> pd.DataFrame:
        """Gets the version of the table on Yellowbrick, provided it is loaded already."""
        sql = self.get_select_query(version)
        return self.yellowbrick.get_table(sql)

    @abc.abstractmethod
    def get_all_versions(self):
        """Gets all versions (even those which are not stored in Yellowbrick)."""
        raise NotImplementedError()

    def exists_on_yellowbrick(self, version: str = None) -> bool:
        """Checks if the version of the table exists on YB"""
        versions = self.get_yellowbrick_versions()
        if version is None:
            return len(versions) > 0
        else:
            return version in versions

    def load_to_yellowbrick_if_needed(self, version: str):
        """
        Checks if the version of the table is in YB. If not, extracts it from the origin database,
        and appends it to Yellowbrick.
        """
        if not self.exists_on_yellowbrick(version=version):
            self.load_to_yellowbrick(version=version)

    @abc.abstractmethod
    def load_to_yellowbrick(self, version: str):
        """
        Abstract method: extracts the date from a specific version from the origin database, and
        appends it to Yellowbrick.
        """
        raise NotImplementedError()


class SnowflakeExternalTable(ExternalTable):
    """
    Class for handling external tables that are stored in Snowflake and we want to use in
    Yellowbrick.
    """

    def __init__(
        self,
        table_name: str,
        version_col: str,
        snowflake_table_name: str,
        snowflake_config: dict,
    ) -> None:
        super().__init__(table_name, version_col)

        # Additional connector: snowflake
        self.snowflake_table_name = snowflake_table_name
        self.snowflake = SnowflakeDatabaseConnector(**snowflake_config)

    def load_to_yellowbrick(self, version: str):
        sql = f"""
        SELECT * FROM {self.snowflake_table_name} WHERE {self.version_col} = '{version}'
        """
        df_snowflake = self.snowflake.get_table(sql)
        self.yellowbrick.create_table(
            df_snowflake, table_name=self.table_name, if_exists="append"
        )

    def get_all_versions(self):
        """Gets all versions (list of strings or dates) available on snowflake"""
        if not self.snowflake.has_table(self.snowflake_table_name):
            return []

        sql = (
            f"""SELECT DISTINCT({self.version_col}) FROM {self.snowflake_table_name}"""
        )
        df_versions = self.snowflake.get_table(sql)

        versions = [
            version.strftime("%Y-%m-%d") if isinstance(version, date) else version
            for version in df_versions[self.version_col]
        ]

        return versions


class SASExternalTable(ExternalTable):
    """Class handling external SAS tables"""

    def __init__(
        self,
        table_name: str,
        version_col: str,
        path: Path,
        pattern: str,
    ) -> None:
        """
        Instantiates the SAS External Table class.

        Args:
            table_name (str): name of the table to store on Yellowbrick
            version (str): version of the table to gather.
            hostname (str): name of the host to connect to
            path (str): path of the folder containing the multiple versions of the file
        """
        super().__init__(table_name, version_col)

        # Path parameters
        # TODO: automatically detect the extension to put less parameters
        self.path = path
        self.pattern = pattern

    def load_to_yellowbrick(self, version: str):
        # Read the data
        filepath = next(Path(file) for file in self.get_all_files() if version in file)
        df_sas, _ = read_sas(filepath)

        # Format data: lowercase the columns names- add the version column
        # TODO: make adding version col optional
        df_sas.columns = [col.lower() for col in df_sas.columns]
        df_sas[self.version_col] = version

        # Store the data into Yellowbrick
        self.yellowbrick.create_table(
            df_sas, table_name=self.table_name, if_exists="append"
        )

    def get_all_versions(self) -> list[str]:
        """Gets all versions (list of strings or dates) available"""
        pattern = re.compile(self.pattern.replace(".*", "(.*)"))
        versions = sorted(
            re.search(pattern, Path(file).stem).group(1)
            for file in self.get_all_files()
        )

        return versions

    def get_all_files(self) -> list[str]:
        """"""
        pattern = re.compile(self.pattern)
        return [
            file for file in os.listdir(self.path) if pattern.match(Path(file).stem)
        ]
