"""Functions to send emails automatically on Outlook."""
import os
import smtplib
from email import encoders
from email.mime.base import MIMEBase
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from typing import Optional


def send_email(
    from_addr: Optional[str] = None,
    to_addrs: Optional[list[str]] = None,
    cc_addrs: Optional[list[str]] = None,
    bcc_addrs: Optional[list[str]] = None,
    subject: Optional[str] = None,
    text: Optional[str] = None,
    html: Optional[str] = None,
    attached_files: Optional[list[str]] = None,
    username: Optional[str] = None,
    password: Optional[str] = None,
    smtp_server: str = "smtp.office365.com",
    smtp_port: int = 587,
):
    """
    Main method to send an email. You can also use the EmailHandler class directly. Fully inspired
        from https://realpython.com/python-send-email/#sending-fancy-emails.

    Args:
        from_addr (Optional[str], optional): address from which to send the mail. If None, uses
            the parameter self.user_mail. Defaults to None.
        to_addrs (list[str]): if given, addresses to send the email to. Defaults to None.
        cc_addrs (Optional[list[str]], optional): If given, addresses to send a copy of the mail
            to. Defaults to None.
        bcc_addrs (Optional[list[str]], optional): If given, addresses to blindly send a copy of
            the mail to. Defaults to None.
        subject (str): subject of the email.
        text (str): body of the email, . Defaults to None (no body).
        html (str): body of the email, HTML format.
        attached_files (Optional[list[str]], optional): If given, path to the files to attach to
            the email. Be careful for these files not to be too big. Defaults to None.
        username (Optional[str], optional): Catalina username. If not specified, will try to
            look in the CATALINA_USERNAME environment variable. Defaults to None.
        password (Optional[str], optional): Catalina password. If not specified, will try to
            look in the CATALINA_PASSWORD environment variable. Defaults to None.
        smtp_server (Optional[str], optional): mailing server to use. Could be
            "smtp.office365.com" (Office 365), "smtp-mail.outlook.com",
            "catalina-com.mail.protection.outlook" or "smtp.sendgrid.net" (Sendgrid).
            Defaults to "smtp.office365.com".
        smtp_port (Optional[str], optional): port could be 587 (standard SMTP port) or 465 (SSL
            port)  Defaults to 587.
    """
    email_handler = EmailHandler(
        username=username,
        password=password,
        smtp_server=smtp_server,
        smtp_port=smtp_port,
    )
    email_handler.send(
        from_addr=from_addr,
        to_addrs=to_addrs,
        cc_addrs=cc_addrs,
        bcc_addrs=bcc_addrs,
        subject=subject,
        text=text,
        html=html,
        attached_files=attached_files,
    )


class EmailHandler:
    """Class handling automatic email sending"""

    def __init__(
        self,
        username: Optional[str] = None,
        password: Optional[str] = None,
        smtp_server: str = "smtp.office365.com",
        smtp_port: int = 587,
    ) -> None:
        """
        Instantiates the email handler.

        Args:
            username (Optional[str], optional): Catalina username. If not specified, will try to
                look in the CATALINA_USERNAME environment variable. Defaults to None.
            password (Optional[str], optional): Catalina password. If not specified, will try to
                look in the CATALINA_PASSWORD environment variable. Defaults to None.
            smtp_server (Optional[str], optional): mailing server to use. Could be
                "smtp.office365.com" (Office 365), "smtp-mail.outlook.com",
                "catalina-com.mail.protection.outlook" or "smtp.sendgrid.net" (Sendgrid).
                Defaults to "smtp.office365.com".
            smtp_port (Optional[str], optional): port could be 587 (standard SMTP port) or 465 (SSL
                port)  Defaults to 587.
        """
        self.smtp_server = smtp_server
        self.smtp_port = smtp_port

        # Username and password
        self.username = username or os.getenv("CATALINA_USERNAME")
        self.user_mail = f"{self.username}@catmktg.com"
        self.password = password or os.getenv("CATALINA_PASSWORD")

        # If no username / password, raise error
        if self.username is None or self.password is None:
            error_message = """
            Please provide a username / password either in the creation of the class, or in the
            CATALINA_USERNAME / CATALINA_PASSWORD environment variables.
            """
            raise ValueError(error_message.strip("\n"))

    def send(
        self,
        from_addr: Optional[str] = None,
        to_addrs: Optional[list[str]] = None,
        cc_addrs: Optional[list[str]] = None,
        bcc_addrs: Optional[list[str]] = None,
        subject: Optional[str] = None,
        text: Optional[str] = None,
        html: Optional[str] = None,
        attached_files: Optional[list[str]] = None,
    ):
        """
        Sends an email using the login / server defined in the class initialization. Fully inspired
        from https://realpython.com/python-send-email/#sending-fancy-emails.

        Args:
            from_addr (Optional[str], optional): address from which to send the mail. If None, uses
                the parameter self.user_mail. Defaults to None.
            to_addrs (list[str]): if given, addresses to send the email to. Defaults to None.
            cc_addrs (Optional[list[str]], optional): If given, addresses to send a copy of the mail
                to. Defaults to None.
            bcc_addrs (Optional[list[str]], optional): If given, addresses to blindly send a copy of
                the mail to. Defaults to None.
            subject (str): subject of the email.
            text (str): body of the email, . Defaults to None (no body).
            html (str): body of the email, HTML format.
            attached_files (Optional[list[str]], optional): If given, path to the files to attach to
                the email. Be careful for these files not to be too big. Defaults to None.
        """
        from_addr = from_addr if from_addr is not None else self.user_mail
        to_addrs = to_addrs if to_addrs is not None else []
        cc_addrs = cc_addrs if cc_addrs is not None else []
        bcc_addrs = bcc_addrs if bcc_addrs is not None else []
        attached_files = attached_files if attached_files is not None else []

        # Create message
        message = MIMEMultipart()
        message["From"] = from_addr
        message["Subject"] = subject

        # Addresses
        # TODO: fix sending with addresses in BCC
        addresses = {"To": to_addrs, "Cc": cc_addrs, "Bcc": bcc_addrs}
        for key, addrs in addresses.items():
            if addrs:
                message[key] = ",".join(addrs)

        # Add body (plain text, HTML)
        bodies = {"plain": text, "html": html}
        for body_type, body in bodies.items():
            if body is not None:
                message.attach(MIMEText(body, body_type))

        # Add attached files
        for filename in attached_files:
            # Open PDF file in binary mode
            with open(filename, "rb") as attachment:
                # Add file as application/octet-stream
                # Email client can usually download this automatically as attachment
                part = MIMEBase("application", "octet-stream")
                part.set_payload(attachment.read())

            # Encode file in ASCII characters to send by email
            encoders.encode_base64(part)

            # Add header as key/value pair to attachment part
            part.add_header(
                "Content-Disposition",
                f"attachment; filename= {filename}",
            )

            # Add attachment to message and convert message to string
            message.attach(part)

        # Send message
        with smtplib.SMTP(self.smtp_server, self.smtp_port) as smtp:
            smtp.starttls()
            smtp.login(self.user_mail, self.password)
            smtp.sendmail(from_addr, to_addrs, message.as_string())
