"""
Tools related to project execution: logging, input parameters loading ...
TODO: add tests load_input_parameters!
"""

import json
import logging
import os
import sys
import time
import warnings
from datetime import datetime, timedelta
from functools import partial, wraps
from inspect import signature
from pathlib import Path
from typing import Callable, Optional, Union
from zoneinfo import ZoneInfo

import pandas as pd


def load_input_parameters() -> str:
    """
    Function that loads input parameters, used in the run of main.py files in analytics projects.
    If there are some arguments, assumes the first one is JSON and uses it. If there are no
    arguments passed from command line, uses the "params.json" file.
    """
    if len(sys.argv) > 1:
        input_params = sys.argv[1]
    else:
        with open("params.json", "r") as file:
            input_params = json.load(file)
        input_params = json.dumps(input_params)

    return input_params


LOGGER_NAME = "catalina_analytics"
DEFAULT_TIMEZONE = ZoneInfo("Europe/Paris")


def get_analytics_logger(
    timezone: Union[str, ZoneInfo, None] = None,
    add_file_logger: bool = False,
    log_folder: Optional[Path] = None,
    reinitialize: bool = False,
) -> logging.Logger:
    """
    Sets up the Catalina analytics logger. If the logger is already set up, it does nothing.

    Args:
        timezone (Union[str, ZoneInfo, None], optional): timezone to input if needed.
            Defaults to Europe/Paris timezone.
        add_file_logger (bool, optional): if True, also logs information to a file. Default file
            will be written in a "log" folder in the current working directory. Custom file can be
            defined on the "log_folder". Defaults to False.
        log_folder (Path, optional): custom folder on which we log the logs. Defaults to None.
        reinitialize (bool, optional): If True, forces the setup to be made again, even if the
            has already been initialized. Defaults to False.
    """
    # Add the parameter
    timezone = timezone if timezone is not None else DEFAULT_TIMEZONE

    # Get the Catalina Analytics Logger
    logger = logging.getLogger(LOGGER_NAME)

    # If we need to reset the loggers, clear them
    if reinitialize is True:
        logger.handlers.clear()

    # Add handlers, if they do not already exist
    if len(logger.handlers) == 0:
        # Creates a console handler
        console_handler = logging.StreamHandler()

        # Add formatter to the proper timezone
        formatter = logging.Formatter("%(levelname)s - %(asctime)s - %(message)s")
        timezone = ZoneInfo(timezone) if isinstance(timezone, str) else timezone
        formatter.converter = lambda *args: datetime.now(timezone).timetuple()

        console_handler.setFormatter(formatter)

        # Adds console handler to the logger and set its level
        logger.addHandler(console_handler)
        logger.setLevel(logging.DEBUG)

        # Change pandas logging configuration
        pd.set_option("display.width", 150)
        pd.options.display.max_colwidth = 100

        # Add file handlers: cwd if add_file_logger is True and no folder specified
        if add_file_logger is True and log_folder is None:
            log_folder = Path.cwd() / "log"

        if log_folder is not None:
            os.makedirs(log_folder, exist_ok=True)
            log_file = f"log_{datetime.now(timezone).strftime('%Y-%m-%d_%H:%M')}.log"
            file_handler = logging.FileHandler(log_folder / log_file, mode="w")
            file_handler.setFormatter(formatter)
            logger.addHandler(file_handler)

    return logger


def setup_analytics_logger(
    timezone: Union[str, ZoneInfo, None] = None,
    add_file_logger: bool = False,
    log_folder: Optional[Path] = None,
    reinitialize: bool = False,
):
    """[DEPRECATED] sets up the analytics logger. Use get_analytics_logger directly."""
    msg = "'setup_analytics_logger' is deprecated, use directly 'get_analytics_logger'"
    warnings.warn(msg, category=DeprecationWarning)

    get_analytics_logger(
        timezone=timezone,
        add_file_logger=add_file_logger,
        log_folder=log_folder,
        reinitialize=reinitialize,
    )


def log_execution(
    func: Callable = None,
    level: Union[str, int] = logging.INFO,
    logger: logging.Logger = None,
    log_signature: bool = False,
    log_return_value: bool = False,
    log_execution_time: bool = False,
):
    """
    Decorator used to log when a function started and ended.

    Args:
        func (Callable): function to apply the decorator to.
        level (Union[str, int], optional): level on which to log information. Can be an int 0 -> 50,
            a string in ['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'] or a level from logging
            (e.g. logging.INFO). If None, uses info logger. Defaults to None.
        logger (Logger, optional): logger to use to log information. If None, uses the Catalina
            Analytics logger. Defaults to None.
        log_signature (bool, optional): If True, adds the signature to the logging.
            Defaults to False.
        log_return_value (bool, optional): If True, adds the return value to the logging.
            Defaults to False.
        log_execution_time (bool, optional): If True, adds the function execution time in seconds.
            Defaults to False.
    """
    # Check if the decorator is run with or without arguments
    if func is None:
        return partial(
            log_execution,
            level=level,
            logger=logger,
            log_signature=log_signature,
            log_return_value=log_return_value,
            log_execution_time=log_execution_time,
        )

    # Core of the function
    logger = get_analytics_logger() if logger is None else logger

    @wraps(func)
    def log_execution_info(*args, **kwargs):
        """Decorated function: logs function start and end."""

        # Log the start of the execution
        if log_signature:
            # Do not show the class in the signature if the function is a method
            show_args = args[1:] if "self" in signature(func).parameters else args
            args_repr = [repr(a) for a in show_args]
            kwargs_repr = [f"{k}={v!r}" for k, v in kwargs.items()]
            signature_repr = ", ".join(args_repr + kwargs_repr)
            start_message = f"Executing {func.__name__}({signature_repr})..."
        else:
            start_message = f"Executing {func.__name__}..."
        logger.log(level, start_message)

        # Log the time before execution of the function
        if log_execution_time:
            start = time.time()

        # Execute the function
        value = func(*args, **kwargs)

        # Log the end of the execution
        base_end_msg = f"Finished executing {func.__name__}"
        return_value_msg, execution_time_msg = "", ""
        if log_return_value:
            return_value_msg = f": returned {value}"
        if log_execution_time:
            seconds = int(time.time() - start)
            readable_time = timedelta(seconds=seconds)
            execution_time_msg = f"Execution time: {readable_time} ({seconds} seconds)."

        end_message = f"{base_end_msg}{return_value_msg}! {execution_time_msg}"
        logger.log(level, end_message)

        return value

    return log_execution_info
