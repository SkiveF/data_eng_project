"""All tools linked to using SAS files: exploding .egp project, reading .sas file..."""
import gzip
import os
import re
import shutil
import warnings
import zipfile
from pathlib import Path
from tempfile import NamedTemporaryFile
from typing import Optional, Union
from xml.etree import ElementTree

import pandas as pd
import pyreadstat
from pyreadstat import metadata_container


def read_sas(
    filepath: Union[str, Path], **kwargs
) -> tuple[pd.DataFrame, metadata_container]:
    """
    Reads a given SAS table (accepted formats, zipped or unzipped: .sas, .sas7bdat).

    Args:
        filepath (Union[str, Path]): path to the file to read.
        kwargs (dict): arguments to pass to the pyreadstat.read_sas7bdat function. It includes:
            - encoding (str): to specify the file encoding
            - metadataonly (bool): to get only the metadata, and an empty DF with correct columns
            - usecols (list[str]): to choose which column to read, to decrease memory consumption
              and speed up the process
            - row_offset (int): to start reading from the n+1th row. row_offset=1 will read file
              starting from the second row
            - row_limit (int): limit of rows to read
            - dates_as_pandas_datetime (bool): if True, converts the dates to pandas datetimes.

    # TODO: add parallel argument to read data even faster
    """
    sas_reader = SASReader(filepath, kwargs)

    return sas_reader.read()


class SASReader:
    """Class to read .sas7bdat and .sas7bdat.gz files."""

    def __init__(self, filepath: Union[str, Path], read_sas_args: dict = None) -> None:
        """
        Class initialization.

        Args:
            filepath (Union[str, Path]): path to the file to read.
            read_sas_args (dict): arguments to pass to the pyreadstat.read_sas7bdat function.
        """
        self.filepath = filepath if isinstance(filepath, Path) else Path(filepath)
        self.read_sas_args = read_sas_args if read_sas_args is not None else {}

    def read(self) -> tuple[pd.DataFrame, metadata_container]:
        """Reads the file and returns its information"""
        if self.filepath.suffix == ".gz":
            return self.read_zipped_file()
        else:
            return self.read_file(self.filepath)

    def read_file(self, filepath: Path) -> tuple[pd.DataFrame, metadata_container]:
        """Reads an unzipped file"""
        df, meta = pyreadstat.read_sas7bdat(filepath, **self.read_sas_args)

        return df, meta

    def read_zipped_file(self) -> tuple[pd.DataFrame, metadata_container]:
        """Reads a zipped file"""
        with NamedTemporaryFile(dir=self.filepath.parent) as temp_file:
            # Unzip the zipped file to a temporary one.
            with gzip.open(self.filepath, "rb") as file_in:
                shutil.copyfileobj(file_in, temp_file)

            # Read the temporary file and deletes it, even if failure to read.
            df, meta = self.read_file(Path(temp_file.name))

        return df, meta


def explode_sas_project(filepath: Path, destination: Optional[Path] = None):
    """
    Explodes a SAS .egp project into a folder containing the associated .sas files.

    Args:
        filepath (Path): path to the .egp file.
        destination (Path): folder to put the extracted SAS files. If None, unzips the file to the
        current working directory.
    """
    SASProjectExploder(filepath, destination=destination).explode()


class SASProjectExploder:
    """Class containing all information from a SAS .egp file"""

    def __init__(self, filepath: Path, destination: Optional[Path] = None) -> None:
        if not os.path.exists(filepath):
            raise ValueError(f"{filepath=} does not exist!")

        # Filepaths
        self.filepath = filepath
        self.destination = destination if destination is not None else Path("")
        self.copy_path = self.destination / self.filepath.name  # Path of the copy
        self.unzip_to = self.destination / self.filepath.stem  # Unzipped file path

        # Parsing arguments
        self.program_groups = []  # type: list[dict[str, str]]

    def explode(self):
        """Explodes the project into"""
        self.copy_to_directory()
        self.unzip_to_directory()
        self.search_for_program_names()
        self.create_appropriate_files()
        self.cleanup()

    def copy_to_directory(self):
        """Copies the file to the appropriate directory."""
        shutil.copyfile(self.filepath, self.copy_path)

    def unzip_to_directory(self):
        """Unzips the file to a folder in the same directory and with the file name"""
        with zipfile.ZipFile(self.copy_path, "r") as egp_project:
            egp_project.extractall(self.unzip_to)

        os.remove(self.copy_path)  # Remove the copied directory

    def search_for_program_names(self):
        """
        Searches the project.xml tree to find appropriate data. Basically, we search groups of
        programs, that are named "programs" or "Programmes". Usually, there is only one, but
        sometimes there are more than one. These elements contains ordered program names that we
        can use as is.
        """
        tree = ElementTree.parse(self.unzip_to / "project.xml")
        root = tree.getroot()

        search_in = "./External_Objects/ProjectTreeView/EGTreeNode/EGTreeNode"
        program_groups = [
            node.findall("EGTreeNode")
            for node in root.findall(search_in)
            if node.find("Label").text in {"Programs", "Programmes"}
        ]
        self.program_groups = [
            {
                program.find("ElementID").text: program.find("Label").text
                for program in programs
            }
            for programs in program_groups
        ]

    def create_appropriate_files(self):
        """
        Creates the .sas files with their appropriate name. We can enumerate since programs seems
        already sorted, which allows to keep the correct sorting in VS Code too. If a file found in
        the .xml file does not exist in the folders, skip it and raise a warning about it.
        """
        for i, programs in enumerate(self.program_groups):
            for j, (program_id, program_name) in enumerate(programs.items()):
                # If a file does not exist in the exploded project, raise a warning & skip file
                if not os.path.isfile(self.unzip_to / program_id / "code.sas"):
                    file = f"{program_name}.sas"
                    msg = f"{file=} was not found in the project but found in the project schema."
                    warnings.warn(msg, category=UserWarning)
                    continue

                # Also removes suspicious characters in file name to avoid Windows / Linux issues
                program_name = re.sub(r"[^\w\-_\. ]", "_", program_name)
                os.replace(
                    src=self.unzip_to / program_id / "code.sas",
                    dst=self.unzip_to / f"{i}.{j}- {program_name}.sas",
                )

    def cleanup(self):
        """Remove all files that aren't .sas files"""
        to_remove = [
            self.unzip_to / file
            for file in os.listdir(self.unzip_to)
            if not file.endswith(".sas")
        ]
        for file in to_remove:
            if os.path.isfile(file):
                os.remove(file)
            else:
                shutil.rmtree(file)
