""" Function that are linked to SQL: file reading, SELECT statement checking..."""
from dataclasses import asdict, dataclass
from pathlib import Path
from subprocess import CompletedProcess
from typing import Any, Optional, Union

from sqlalchemy.engine import CursorResult

from analytics_toolkit.config import YellowbrickDatabases


def is_sql_select_query(sql: str) -> bool:
    """
    Check if the sql statement is a SQL select query. Otherwise, it is probably a table name.
    Does not work with WITH statements preceding SELECT clause.
    TODO: make preceding WITH clauses work

    Args:
        sql (str): generally SQL query or table name

    Returns:
        bool: True if the sql statement is a SQL query, False otherwise.
    """
    starts_with_select = sql.strip().upper().startswith("SELECT")
    # Checking spaces, so that tables starting with select are not considered as queries
    has_spaces = " " in sql or "\n" in sql

    return starts_with_select and has_spaces


def is_table_name(sql: str) -> bool:
    """
    Checks if a SQL string is a table name. Otherwise, it is probable a SQL select statement.
    TODO: make the connector able to detect table names with spaces? Like "[table name]"

    Args:
        sql (str): generally SQL query or table name

    Returns:
        bool: True if the sql string is a table name, False otherwise.
    """
    has_spaces = " " in sql or "\n" in sql

    return not has_spaces


def get_n_affected_rows(result: Union[CompletedProcess, CursorResult]) -> int:
    """
    Gets the number of affected rows from a SQL Query result.

    Args:
        result (Union[CompletedProcess, CursorResult]): SQL Query result, either from YBSQL
        (CompletedProcess) or directly from SQLAlchemy (CursorResult).

    Returns:
        int: number of rows affected by the query (INSERT, DELETE, SELECT ...)
    """
    if isinstance(result, CursorResult):
        return result.rowcount
    elif isinstance(result, CompletedProcess):
        message: str = result.stdout.decode("UTF-8")
        return int(message.strip("\n").split("\n")[-1].split(" ")[-1])
    else:
        message = (
            "'get_n_affected_rows' handles SQL Query result of the CompletedProcess"
            f" or CursorResult instances only. Given type is {type(result)}. Aborting."
        )
        raise ValueError(message)


@dataclass
class EmptyDataClass:
    """Empty Dataclass to give to tables & dates by default."""


class SQLReader:
    """
    Class to read SQL files and format them efficiently. Indeed, all databases, table names and
    dates can be filled automatically without specifying them during the read query(ies) methods.
    """

    def __init__(
        self, sql_path: Optional[Path] = None, databases=None, tables=None, dates=None
    ) -> None:
        """
        Class initialization.

        Args:
            sql_path (Path): path of the folder containing the SQL files to read. If None, uses the
                current working directory.
            databases: Dataclass containing the databases to use, so that they can be automatically
                formatted in the SQL queries.
            tables: Dataclass containing the tables to use, so that they can be automatically
                formatted in the SQL queries.
            dates: Dataclass containing the databases to use, so that they can be automatically
                formatted in the SQL queries.
        """
        self.sql_path = sql_path if sql_path is not None else Path("")
        self.databases = databases if databases is not None else YellowbrickDatabases()
        self.tables = tables if tables is not None else EmptyDataClass()
        self.dates = dates if dates is not None else EmptyDataClass()

    def read_query(self, file: str, **kwargs) -> str:
        """
        Reads a file containing a single SQL statement and formats it with the keyword arguments.

        Args:
            file (str): name of the SQL file to read

        Returns:
            str: formatted SQL query, based on the given keyword arguments.
        """
        query = self._read_sql_file(file, **kwargs)

        return query

    def read_queries(self, file: str, keys: list[str], **kwargs) -> dict[Any, str]:
        """
        Reads a file containing multiple SQL queries, formats it, and returns a dictionnary with
        the keys given as argument.

        Args:
            file (str): name of the SQL file to read
            keys (list): [description]

        Returns:
            dict[str, str]: dict: key=keys given, values=SQL queries
        """
        sql = self._read_sql_file(file, **kwargs)
        sql_parts = [part for part in sql.split(";") if part.strip("\n ") != ""]
        if len(sql_parts) != len(keys):
            raise ValueError(f"Length mismatch: {len(sql_parts)=} but {len(keys)=}")

        queries = {label: query for (label, query) in zip(keys, sql_parts)}

        return queries

    def _read_sql_file(self, file: str, **kwargs) -> str:
        """Reads a SQL file."""
        sql_file_path = self.sql_path / file

        with open(sql_file_path, "r") as file:
            # Read sql file line by line and delete comments (starting with '--')
            sql = "".join(line.split("--")[0] for line in file).removesuffix(";")

        # Formats database names automatically - add "public" schema if needed
        format_dbs = {
            f"db_{key}": f"{value}.public" if "." not in value else value
            for key, value in asdict(self.databases).items()
        }

        # Formats table names automatically - handle dataclasses with two levels too
        format_tables = {
            inner_key: inner_value
            for key, value in asdict(self.tables).items()
            for inner_key, inner_value in self._prepare_table(key, value).items()
        }

        # Finally, formats dates too
        format_dates = {
            f"date_{key}": value for key, value in asdict(self.dates).items()
        }

        # Groups all formats needed + custom arguments given in kwargs
        format_with = format_dbs | format_tables | format_dates | kwargs
        sql = sql.format(**format_with)

        return sql

    @staticmethod
    def _prepare_table(key: str, value: Union[str, dict[str, str]]) -> dict[str, str]:
        """Small method to extract inner keys if the value is a dict."""
        if isinstance(value, dict):
            return {
                f"table_{key}_{inner_key}": inner_value
                for inner_key, inner_value in value.items()
            }
        else:
            return {f"table_{key}": value}
